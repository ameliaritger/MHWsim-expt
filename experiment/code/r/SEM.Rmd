---
title: "SEM"
author: "Sam Bogan"
date: "2024-12-09"
output: html_document
---

# Load libraries 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(brms)
library(lavaan)
library(tidyverse)
```

# Load data 
```{r, message=FALSE}
# Uncomment and run these two lines ONE TIME to load temperature/body size data, then save the file to your local machine
#source("readRPiData.R", local = knitr::knit_global())
#source("readBodySizeData.R", local = knitr::knit_global())

source("mergeAllData.R", local = knitr::knit_global())

#Load temperature data AFTER you have run source(ReadRPiData)
rpi_temp <- read_csv(here("experiment", "data", "rpi_temp.csv"))

weekly_temp <- read_csv(here("experiment", "data", "weekly_temperature.csv"))

daily_temp <- read_csv(here("experiment", "data", "three_day_temperature.csv")) %>%
  mutate(date = if_else(date==ymd("2023-09-29"), ymd("2023-10-01"), date),
         tank = as.factor(tank),
         treatment = as.factor(if_else(treatment=="chill", "cold", treatment)))
```

# Wrangle data

```{r}
all_temp <- all %>%
  left_join(daily_temp, by = c("tank", "treatment", "date")) %>%
  mutate(tank_date = paste(date, tank, sep = "_"),
         tank_genet = paste(tank, genet, sep = "_"),
         date_num = as.numeric(date - as.Date("2023-10-01")),
         genet = as.numeric(genet)) %>%
  arrange(date_num) %>%
  group_by(tank_genet) %>%
  mutate(n_rel = n_true / first(n_true)) %>% # relative to starting number
  ungroup() %>%
  # Z score all data
  mutate(sc_size = scale(avg_size)[, 1], # Amelia changed size to use diameter in mm rather than average biomass in g
         sc_n = scale(n_rel)[, 1], # Amelia changed this to relative n from true n, to account for differences in starting number of polyps
         sc_temp = scale(avg_temp)[, 1], # weekly average temperature from previous Sat-Fri
         sc_behavior = scale(percent_fully_open)[, 1]) %>% # Amelia changed this to %fully open, because that variable is used in other analyses
  arrange(date) %>% 
  group_by(tank_genet) %>%
  mutate(sc_size_lag = ifelse(is.na(sc_size), NA, lag(sc_size, 2)),
         sc_n_lag = lag(sc_n, 1),
         sc_behavior_lag = lag(sc_behavior, 1)) %>%
  ungroup()
```

# Bayes SEM

```{r, eval=FALSE}

# First pass non time-series, Bayesian model
sem1_rand <- brm(
  bf(scale(avg_biomass_g) ~ scale(n_true) + scale(avg_temp) + scale(percent_open)) +
    bf(scale(n_true) ~ scale(avg_temp) + (1|genet)) +
    bf(scale(percent_open) ~ scale(avg_temp)) + # Pressure is gaussian
    set_rescor(rescor = FALSE), # Temp is gaussian 
  data = all_temp,
  family = gaussian(), # Variance family for count data w/ zeros
  chains = 4, iter = 10000,
  save_pars = save_pars(all = TRUE)
)

summary(sem1_rand)

```

# Frequentist SEM

```{r}
hist(all_temp$sc_n)
qqnorm(all_temp$sc_n)
qqline(all_temp$sc_n)

# Define sem structure
sem1_freq <- '
  # Regressions
  sc_size ~ sc_n + sc_temp + sc_behavior
  sc_n ~ sc_temp + genet
  sc_behavior ~ sc_temp
  
  # Random effect of genet
  genet ~~ genet
'

# Fit the sem
fit <- sem(sem1_freq, data = all_temp)

# Print summary
summary(fit, fit.measures = TRUE)
```

## Multilevel SEM to account for repeated measures (maybe?)
```{r}
sem_mlm <- '
  # within-group
  level: 1
  sc_size ~ sc_n + sc_temp + sc_behavior
  sc_n ~ sc_temp
  sc_behavior ~ sc_temp
  
  # between-groups
  level: 2
  sc_size ~ genet
  sc_n ~ genet
  sc_behavior ~ genet

  # random effect (variation between tank-genet combinations)
  tank_genet ~~ tank_genet
'

# Fit the model
fit_mlm <- sem(sem_mlm, 
               data = all_temp,
               cluster = "tank_genet") # this is explicit repeated measures part

summary(fit_mlm, fit.measures = TRUE)
```

## Add a temporal autoregressive component

### Make a new df to scale explicitly using tank_genet groupings
```{r}
all_temp_ar <- all %>%
  left_join(daily_temp, by = c("tank", "treatment", "date")) %>%
  mutate(tank_date = paste(date, tank, sep = "_"),
         tank_genet = paste(tank, genet, sep = "_"),
         date_num = as.numeric(date - as.Date("2023-10-01")),
         genet = as.numeric(genet)) %>%
  arrange(date_num) %>%
  group_by(tank_genet) %>%
  mutate(n_rel = n_true / first(n_true),
         sc_size = scale(avg_size)[, 1], # Amelia changed size to use diameter in mm rather than average biomass in g
         sc_n = scale(n_rel)[, 1], # Amelia changed this to relative n from true n, to account for differences in starting number of polyps
         sc_temp = scale(avg_temp)[, 1], # weekly average temperature from previous Sat-Fri
         sc_behavior = scale(percent_fully_open)[, 1], # Amelia changed this to %fully open, because that variable is used in other analyses
         sc_size_lag = ifelse(is.na(sc_size), NA, lag(sc_size, 2)),
         sc_size_lag2 = ifelse(is.na(sc_size), NA, lag(sc_size, 4)),
         sc_n_lag = lag(sc_n, 1),
         sc_n_lag2 = lag(sc_n, 2),
         sc_behavior_lag = lag(sc_behavior, 1),
         sc_behavior_lag2 = lag(sc_behavior, 2)) %>%
  ungroup()
```

### Generate the temporal AR model - *This is the current "final" model*
```{r}
sem_ar <- '
  sc_size ~ sc_n + sc_temp + sc_behavior
  sc_n ~ sc_temp
  sc_behavior ~ sc_temp
  
  # autoregressive path
  sc_size ~ sc_size_lag # AR correlation = 0.75
  sc_n ~ sc_n_lag # AR correlation = 0.86
  sc_behavior ~ sc_behavior_lag # AR correlation is weak but significant
'

# Fit the model
fit_ar <- sem(sem_ar,
              data = all_temp_ar,
              cluster = "tank_genet") #this handles the random effect

summary(fit_ar, fit.measures = TRUE)
```

# Everything below here is what was used to check model parameters

## Here is a multilevel SEM (that is overly complex): 
```{r}
sem_mlm_ar <- '
  # within-group
  level: 1
  sc_size ~ sc_n + sc_temp + sc_behavior
  sc_n ~ sc_temp
  sc_behavior ~ sc_temp
  
  # autoregressive path
  sc_size ~ sc_size_lag
  sc_n ~ sc_n_lag
  sc_behavior ~ sc_behavior_lag

  # between-groups: random intercepts capture baseline diffs
  level: 2
  sc_size ~ 1
  sc_n ~ 1
  sc_behavior ~ 1
'

fit_mlm_ar <- sem(sem_mlm_ar, 
                  data = all_temp_ar,
                  cluster = "tank_genet")
```

## Plot up the residuals of the multilevel model
```{r}
pred_mat <- lavPredict(fit_ar, type = "ov")
all_temp_ar$resid_size <- all_temp_ar$sc_size - pred_mat[, "sc_size"]
all_temp_ar$resid_behavior <- all_temp_ar$sc_behavior - pred_mat[, "sc_behavior"]
all_temp_ar$resid_n <- all_temp_ar$sc_n - pred_mat[, "sc_n"]

# Residual plots
ggplot(all_temp_ar, aes(x=sc_n_lag, y=resid_n)) + geom_point() + geom_smooth()
ggplot(all_temp_ar, aes(x=sc_behavior_lag, y=resid_behavior)) + geom_point() + geom_smooth()
ggplot(all_temp_ar, aes(x=sc_size_lag, y=resid_size)) + geom_point() + geom_smooth()

# Compare across genets
ggplot(all_temp_ar, aes(x = factor(genet), y = resid_size)) +
  geom_violin() +
    theme_classic() +
    ylab("Residual sc_size") +
    xlab("Genet")

ggplot(all_temp_ar, aes(x = factor(genet), y = resid_n)) +
  geom_violin() +
    theme_classic() +
    ylab("Residual sc_n") +
    xlab("Genet")

ggplot(all_temp_ar, aes(x = factor(genet), y = resid_behavior)) +
  geom_violin() +
    theme_classic() +
    ylab("Residual sc_behavior") +
    xlab("Genet")
```

From these plots, indicative that there is 1) temporal autocorrelation with N and Size and 2) there is no meaningful level 2 genet variation, so multilevel SEM doesn't appear necessary (plus the SEM variances at level 2 are very nearly 0). From checking model parameters including lag2, the added complexity doesn't result in a significantly improved model (most of the parameter estimates don't change).

```{r}
# 1️⃣ Get predicted values and residuals
pred_mat <- lavPredict(fit_ar, type = "ov")

all_temp_ar <- all_temp_ar %>%
  mutate(
    resid_size     = sc_size - pred_mat[, "sc_size"],
    resid_n        = sc_n - pred_mat[, "sc_n"],
    resid_behavior = sc_behavior - pred_mat[, "sc_behavior"]
  )

# 2️⃣ Gather residuals and lags into long format for easy plotting
resid_long <- all_temp_ar %>%
  select(genet, tank_genet,
         resid_size, resid_n, resid_behavior,
         sc_size_lag, sc_size_lag2,
         sc_n_lag, sc_n_lag2,
         sc_behavior_lag, sc_behavior_lag2) %>%
  pivot_longer(
    cols = starts_with("resid"),
    names_to = "variable",
    values_to = "residual"
  ) %>%
  mutate(
    lag1 = case_when(
      variable == "resid_size"     ~ sc_size_lag,
      variable == "resid_n"        ~ sc_n_lag,
      variable == "resid_behavior" ~ sc_behavior_lag
    ),
    lag2 = case_when(
      variable == "resid_size"     ~ sc_size_lag2,
      variable == "resid_n"        ~ sc_n_lag2,
      variable == "resid_behavior" ~ sc_behavior_lag2
    )
  )

# 3️⃣ Plot residuals vs lag1 and lag2
ggplot(resid_long, aes(x = lag1, y = residual)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", color = "blue") +
  facet_wrap(~variable, scales = "free_x") +
  labs(title = "Residuals vs Lag1 (AR1 check)",
       x = "Lag1", y = "Residual")

df <- all_temp_ar %>%
  group_by(tank_genet) %>%
  summarise(
    acf_size = list(acf(na.omit(sc_size), plot = FALSE)$acf),
    acf_n = list(acf(na.omit(sc_n), plot = FALSE)$acf),
    acf_behavior = list(acf(na.omit(sc_behavior), plot = FALSE)$acf))
```

Residual plots are still funky but adding tons of lag (e.g. lag 7) is the only way to improve, but I only have 40 dates in the timeseries so lag 7 ultimately doesn't make sense for this dataset.
